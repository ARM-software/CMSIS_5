/*----------------------------------------------------------------------------
  MISRA_C_2012.lnt
  MISRA C 2012 rule configuration file for PC-lint
 *----------------------------------------------------------------------------*/

// include MISRA C 2012 PC-lint file
au-misra3.lnt

+rw(restrict)
-rw_asgn(__restrict,restrict)
-rw_asgn(__restrict__,restrict)
-rw_asgn(__RESTRICT,restrict)

-esym(534,__disable_irq)
-esym(534,__disable_fiq)

-emacro(9027, INT32_MIN)

// <<< Use Configuration Wizard in Context Menu >>>

// <h> Checker for Misra C 2012 rules

// <h> Directive 1
/**** Dir 1.1 (Req) ************/
// <n> Directive 1.1 (required): Any implementation-defined behaviour on which the output of the program depends shall be documented and understood
//  <i> *** NOT CHECKED *** not statically checkable
// </h>

// <h> Directive 2
/**** Dir 2.1 (Req) ************/
// <!c> Directive 2.1 (required): All source files shall compile without any compilation errors
    //-e950                      /* flag non-standard word or construct */
    //-elib(950)
// </c>
// </h>

// <h> Directive 3
/**** Dir 3.1 (Req) ************/
// <n> Directive 3.1 (required): All code shall be traceable to documented requirements
//  <i> *** NOT CHECKED *** not statically checkable
// </h>

// <h> Directive 4 Code design
/**** Dir 4.1 (Req) ************/
// <n> Directive 4.1 (required): Run-time failures shall be minimized
//  <i> *** NOT CHECKED *** not statically checkable

/**** Dir 4.2 (Adv) ************/
// <n> Directive 4.2 (advisory): (required): All usage of assembly language should be documented
//  <i> *** NOT CHECKED *** not statically checkable

/**** Dir 4.3 (Req) ************/
// <!c> Directive 4.3 (required): Assembly language shall be encapsulated and isolated
	//-esym(586, asm)
// </c>

/**** Dir 4.4 (Adv) ************/
// <!c> Directive 4.4 (advisory): Sections of code should not be "commented out"
    //-e602                  /* comment within comment */
    //-elib(602)
// </c>

/**** Dir 4.5 (Adv) ************/
// <!c> Directive 4.5 (advisory): Identifiers in the same name space with overlapping visibility should be typographically unambiguous
    //-e9046	  	     /* typographical ambiguity */
    //-elib(9046)
// </c>

/**** Dir 4.6 (Adv) ************/
// <!c> Directive 4.6 (advisory): typedefs that indicate size and signedness should be used in place of the basic numerical types
    //-e970               /* flag modifiers used outside of typedefs */
    //-elib(970)
// </c>

/**** Dir 4.7 (Req) ************/
// <!c> Directive 4.7 (required): If a function returns error information, then that error information shall be tested
    //-e534               /* ignoring return value of function */
    //-elib(534)
// </c>

/**** Dir 4.8 (Adv) ************/
// <!c> Directive 4.8 (advisory): If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden
    //-e9045               /* non-hidden definition of type */
    //-elib(9045)
// </c>

/**** Dir 4.9 (Adv) ************/
// <!c> Directive 4.9 (advisory): A function should be used in preference to a function-like macro where they are interchangeable
    //-e9026               /* function-like macro defined */
    //-elib(9026)
// </c>

/**** Dir 4.10 (Req) ************/
// <!c> Directive 4.10 (required): Precautions shall be taken in order to prevent the contents of a header file being included more than once
    //-e451             /* Header repeatedly included without guard */
    //-elib(451)
// </c>

/**** Dir 4.11 (Req) ************/
// <n> Directive 4.11 (required): The validity of values passed to library functions shall be checked
//  <i> The arguments to over 100 calls to standard library functions are monitored;
//  <i> users can specify additional constraints for other functions

/**** Dir 4.12 (Req) ************/
// <!c> Directive 4.12 (required): Dynamic memory allocation shall not be used
    //-esym(586, calloc)
    //-esym(586, malloc)
    //-esym(586, realloc)
    //-esym(586, free)
// </c>

/**** Dir 4.13 (Adv) ************/
// <!c> Directive 4.13 (advisory): Functions which are designed to provide operations on a resource should be called in an appropriate sequence
    //-e480
    //-elib(480)
    //-e481
    //-elib(481)
// </c>
// </h>

// <h> Rules 1.x: A standard C environment
/**** Rule 1.1 (Req) ************/
// <!c> Rule 1.1 (required): The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits
    //-e950                      /* flag non-standard word or construct */
    //-elib(950)
// </c>

/**** Rule 1.2 (Adv) ************/
// <!c> Rule 1.2 (advisory): Language extensions should not be used
    //-e950                      /* flag non-ANSI word or construct */
    //-elib(950)
// </c>

/**** Rule 1.3 (Req) ************/
// <!c> Rule 1.3 (required): There shall be no occurrence of undefined or critical unspecified behaviour
    //-e406   /* unclosed comment */
    //-elib(406)
    //-e27    /* illegal character */
    //-elib(27)
    //-e2     /* unclosed quote */
    //-elib(2)
    //-e31    /* symbol redefinition */
    //-elib(31)
    //-e40    /* undeclared identifier */
    //-elib(40)
    //-e401   /* symbol not previously declared static */
    //-elib(401)
    //-e31    /* symbol redefinition */
    //-elib(31)
    //-e604   /* returning address of auto variable */
    //-elib(604)
    //-e934   /* taking address of near auto variable */
    //-elib(934)
    //-e606   /* non-ANSI escape sequence */
    //-elib(606)
    //-e9020   /* header name with non-standard character */
    //-elib(9020)
    //-e86    /* structure has no data elements */
    //-elib(86)
    //-e64    /* type mismatch */
    //-elib(64)
    //-e67    /* cannot cast between types */
    //-elib(67)
    //-e144   /* non-existent return value */
    //-elib(144)
    //-e564   /* variable depends on order of evaluation */
    //-elib(564)
    //-e54    /* division by 0 */
    //-elib(54)
    //-e414   /* possible division by 0 */
    //-elib(414)
    //-e795   /* conceivable division by 0 */
    //-elib(795)
    //-e413   /* likely use of null pointer */
    //-elib(413)
    //-e415   /* out-of-bounds pointer */
    //-elib(415)
    //-e416   /* out-of-bounds pointer */
    //-elib(416)
    //-e428   /* negative subscript */
    //-elib(428)
    //-e740   /* unusual pointer cast */
    //-elib(740)
    //-e71    /* cannot cast */
    //-elib(71)
    //-e504   /* unusual shift */
    //-elib(504)
    //-e629   /* static class for function */
    //-elib(629)
    //-e158   /* assignment increases capability */
    //-elib(158)
    //-e158   /* assignment increases capability */
    //-elib(158)
    //-estring(10,"a numeric constant")  /* expecting a numeric constant */
    //-e136   /* illegal macro name */
    //-elib(136)
    //-e558   /* too few arguments */
    //-elib(558)
    //-e719   /* too many arguments */
    //-elib(719)
    //-e557   /* unrecognized format */
    //-elib(557)
    //-e437   /* passing struct to ellipsis */
    //-elib(437)
    //-e449   /* previously deallocated pointer */
    //-elib(449)
    //-esym(424,free) /* inappropriate deallocation */
    //-e419   /* data overrun */
    //-elib(419)
    //-e564   /* variable depends on order of evaluation */
    //-elib(564)
    //-e931   /* both sides of an expression have side-effects */
    //-elib(931)
    //-e564   /* variable depends on order of evaluation */
    //-elib(564)
    //-e9023   /* multiple '#/##' operators in macro definition */
    //-elib(9023)
// </c>
// </h>

// <h> Rules 2.x: Unused code
/**** Rule 2.1 (Req) ************/
// <!c> Rule 2.1 (required): A project shall not contain unreachable code
    //-e506       /* constant value boolean */
    //-elib(506)
    //-e527       /* unreachable */
    //-elib(527)
    //-e681       /* loop not entered */
    //-elib(681)
    //-e827       /* loop not reachable */
    //-elib(827)
// </c>

/**** Rule 2.2 (Req) ************/
// <!c> Rule 2.2 (required): There shall be no dead code
    //-e438       /* value not used */
    //-elib(438)
    //-e505       /* redundant argument to comma */
    //-elib(505)
    //-e520       /* highest operator has no side effects */
    //-elib(520)
    //-e521       /* highest operator has no side effects */
    //-elib(521)
    //-e522       /* highest operator has no side effects */
    //-elib(522)
// </c>

/**** Rule 2.3 (Adv) ************/
// <!c> Rule 2.3 (advisory): A project should not contain unused type declarations
    //-e751	   /* local typedef not referenced */
    //-elib(751)
    //-e756	   /* global not referenced */
    //-elib(756)
// </c>

/**** Rule 2.4 (Adv) ************/
// <!c> Rule 2.4 (advisory): A project should not contain unused tag declarations
    //-e753	   /* local tag not referenced */
    //-elib(753)
    //-e9058
    //-elibsym(9058)
// </c>

/**** Rule 2.5 (Adv) ************/
// <!c> Rule 2.5 (advisory): A project should not contain unused macro declarations
    //-e750	   /* local macro not referenced */
    //-elib(750)
    //-e755	   /* global macro not referenced */
    //-elib(755)
// </c>

/**** Rule 2.6 (Adv) ************/
// <!c> Rule 2.6 (advisory): A function should not contain unused label declarations
    //-e563	   /* label not referenced */
    //-elib(563)
// </c>

/**** Rule 2.7 (Adv) ************/
// <!c> Rule 2.7 (advisory): There should be no unused parameters in functions
    //-e715      	     /* not referenced */
    //-elib(715)
// </c>
// </h>

// <h> Rules 3.x: Comments
/**** Rule 3.1 (Req) ************/
// <!c> Rule 3.1 (required): The character sequences /* and // shall not be used within a comment
    //-e602                  /* comment within comment */
    //-elib(602)
    //-e9059
    //-elib(9059)
    //-e9066
    //-elib(9066)
// </c>

/**** Rule 3.2 (Req) ************/
// <!c> Rule 3.2 (required): Line-splicing shall not be used in // comments
    //-e427      	     /* C++ comment ends in \\ */
    //-elib(427)
// </c>
// </h>

// <h> Rules 4.x: Character sets and lexical conventions
/**** Rule 4.1 (Req) ************/
// <!c> Rule 4.1 (required): Octal and hexadecimal escape sequences shall be terminated
    //-e9039                              /* prohibited escape sequence */
    //-elib(9039)
// </c>

/**** Rule 4.2 (Adv) ************/
// <!c> Rule 4.2 (advisory): Trigraphs should not be used
    //-e584                       /* activate trigraph detected message */
    //-elib(584)
    //-e739                       /* activate trigraph in string message */
    //-elib(739)
    //-e9060                       /* trigraph in comment */
    //-elib(9060)
// </c>
// </h>

// <h> Rules 5.x: Identifiers
/**** Rule 5.1 (Req) ************/
// <!c> Rule 5.1 (required): External identifiers shall be distinct
    //-e621       /* Identifier clash - length set by -idlen */
    //-elib(621)
// </c>

/**** Rule 5.2 (Req) ************/
// <!c> Rule 5.2 (required): Identifiers declared in the same scope and name space shall be distinct
    //-e621       /* Identifier clash - length set by -idlen */
    //-elib(621)
// </c>

/**** Rule 5.3 (Req) ************/
// <!c> Rule 5.3 (required): An identifier declared in an inner scope shall not hide an identifier declared in an outer scope
    //-e578               /* enable reports of name hiding */
    //-elib(578)
// </c>

/**** Rule 5.4 (Req) ************/
// <!c> Rule 5.4 (required): Macro identifiers shall be distinct
    //-e621       /* Identifier clash - length set by -idlen */
    //-elib(621)
// </c>

/**** Rule 5.5 (Req) ************/
// <!c> Rule 5.5 (required): Identifiers shall be distinct from macro names
    //-e123       /* macro defined with arguments */
    //-elib(123)
    //-e621       /* Identifier clash - length set by -idlen */
    //-elib(621)
    //-e9061                       /* non-distinct identifier */
    //-elib(9061)
// </c>

/**** Rule 5.6 (Req) ************/
// <!c> Rule 5.6 (required): A typedef name shall be a unique identifier
    //-e578               /* enable reports of name hiding */
    //-elib(578)
    //-e623               /* redefining the storage class of symbol */
    //-elib(623)
    //-esym(9062,typedef)  /* non-unique typedef */
    //-elib(9062)
// </c>

/**** Rule 5.7 (Req) ************/
// <!c> Rule 5.7 (required): A tag name shall be a unique identifier
    //-e407               /* Inconsistent use of tag */
    //-elib(407)
    //-e578               /* Declaration of Symbol hides Symbol */
    //-elib(578)
    //-e14                /* Symbol previously defined */
    //-elib(14)
    //-e15                /* Symbol redeclared */
    //-elib(15)
    //-e631               /* Tag defined differently */
    //-elib(631)
    //-e9062                       /* non-unique tag */
    //-elib(9062)
// </c>

/**** Rule 5.8 (Req) ************/
// <!c> Rule 5.8 (required): Identifiers that define objects or functions with external linkage shall be unique
    //-e401           /* Symbol not previously declared static */
    //-elib(401)
    //-e578           /* Declaration of Symbol hides Symbol */
    //-elib(578)
    //-e580           /* enable reports of name hiding */
    //-elib(580)
// </c>

/**** Rule 5.9 (Adv) ************/
// <!c> Rule 5.9 (advisory): Identifiers that define objects \or functions with internal linkage should be unique
    //-e578           /* enable reports of name hiding */
    //-elib(578)
    //-e580           /* enable reports of name hiding */
    //-elib(580)
// </c>
// </h>

// <h> Rules 6.x: Types
/**** Rule 6.1 (Req) ************/
// <!c> Rule 6.1 (required): Bit-fields shall only be declared with an appropriate type
    //-e46                /* field type should be int */
    //-elib(46)
    //-e806               /* small bit field is signed rather than unsigned */
    //-elib(806)
// </c>

/**** Rule 6.2 (Req) ************/
// <!c> Rule 6.2 (required): Single-bit named bit fields shall not be of a signed type
    //-e9088               /* named signed single-bit bit-field */
    //-elib(9088)
// </c>
// </h>

// <h> Rules 7.x: Literals and constants
/**** Rule 7.1 (Req) ************/
// <!c> Rule 7.1 (required): Octal constants shall not be used
    //-e9001                              /* Octal constant used */
    //-elib(9001)
// </c>

/**** Rule 7.2 (Req) ************/
// <!c> Rule 7.2 (required): A "u" or "U" suffix shall be applied to all integer constants that are represented in an unsigned type
    //-e9048                              /* unsigned literal without 'U' suffix */
    //-elib(9048)
// </c>

/**** Rule 7.3 (Req) ************/
// <!c> Rule 7.3 (required): The lowercase character "l" shall not be used in a literal suffix
    //-e620                           /* suspicious constant */
    //-elib(620)
    //-e9057                          /* "l" after "u" in literal suffix */
    //-elib(9057)
// </c>

/**** Rule 7.4 (Req) ************/
// <!c> Rule 7.4 (required): A string literal shall not be assigned to an object unless the object's type is "pointer to const-qualified char"
    //-e489                           /* attempting to modify a string literal */
    //-elib(489)
    //-e1776                          /* string literal not const safe */
    //-elib(1776)
    //-e1778                          /* assignment of string literal not const safe */
    //-elib(1778)
// </c>
// </h>

// <h> Rules 8.x: Declarations and definitions
/**** Rule 8.1 (Req) ************/
// <!c> Rule 8.1 (required): Types shall be explicitly specified
    //-e601                           /* no explicit type */
    //-elib(601)
    //-e745                           /* function has no explicit type */
    //-elib(745)
    //-e808                           /* no explicit type */
    //-elib(808)
    //-e832                           /* parameter has no explicit type */
    //-elib(832)
    //-e939                           /* return type defaults to int */
    //-elib(939)
// </c>

/**** Rule 8.2 (Req) ************/
// <!c> Rule 8.2 (required): Function types shall be in prototype form with named parameters
    //-e937                     /* old-style function declaration */
    //-elib(937)
    //-e745                           /* function has no explicit type */
    //-elib(745)
    //-e939                           /* return type defaults to int */
    //-elib(939)
    //-e18                          /* symbol redeclared */
    //-elib(18)
    //-e936                         /* old-style function definition */
    //-elib(936)
    //-e955                         /* param name missing from prototype */
    //-elib(955)
// </c>

/**** Rule 8.3 (Req) ************/
// <!c> Rule 8.3 (required): All declarations of an object or function shall use the same names and type qualifiers
    //-e18                          /* symbol redeclared */
    //-elib(18)
    //-e516                         /* argument type conflict */
    //-elib(516)
    //-e532                         /* return mode of symbol inconsistent */
    //-elib(532)
    //-e9072                        /* parameter list differs */
    //-elib(9072)
// </c>

/**** Rule 8.4 (Req) ************/
// <!c> Rule 8.4 (required): A compatible declaration shall be visible when an object or function with external linkage is defined
    //-e15        /* symbol redeclared */
    //-elib(15)
    //-e64        /* flag type mismatch */
    //-elib(64)
    //-e516       /* argument type mismatch */
    //-elib(516)
    //-e9075                        /* extern defined without prior declaration */
    //-elib(9075)
// </c>

/**** Rule 8.5 (Req) ************/
// <!c> Rule 8.5 (required): An external object or function shall be declared once in one and only one file
    //-e9004        /* object/function previously declared */
    //-elib(9004)
// </c>

/**** Rule 8.6 (Req) ************/
// <!c> Rule 8.6 (required): An identifier with external linkage shall have exactly one external definition
    //-e14        /* Symbol previously defined */
    //-elib(14)
// </c>

/**** Rule 8.7 (Adv) ************/
// <!c> Rule 8.7 (advisory): Functions and objects should not be defined with external linkage if they are referenced in only one translation unit
    //-e765        /* could be made static */
    //-elib(765)
// </c>

/**** Rule 8.8 (Req) ************/
// <!c> Rule 8.8 (required): The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage
    //-e839           /* storage class assumed static */
    //-elib(839)
// </c>

/**** Rule 8.9 (Adv) ************/
// <!c> Rule 8.9 (advisory): An object should be defined at block scope if its identifier only appears in a single function
    //-e9003        /* could define variable at block scope */
    //-elib(9003)
// </c>

/**** Rule 8.10 (Req) ************/
// <!c> Rule 8.10 (required): An inline function shall be declared with the static storage class
    //-e695    	     /* inline function without storage-class specifier */
    //-elib(695)
    //-esym(9056,extern)     /* inline function defined with extern */
// </c>

/**** Rule 8.11 (Adv) ************/
// <!c> Rule 8.11 (advisory): When an array with external linkage is declared, its size should be explicitly specified
    //-e9067             /* array has no dimension or initializer */
    //-elib(9067)
// </c>

/**** Rule 8.12 (Req) ************/
// <!c> Rule 8.12 (required): Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique
    //-e488	/* duplicate enumerator values */
    //-elib(488)
// </c>

/**** Rule 8.13 (Adv) ************/
// <!c> Rule 8.13 (advisory): A pointer should point to a const-qualified type whenever possible
    //-e818	/* pointer could be declared pointing to const */
    //-elib(818)
    //-e844	/* pointer could be declared pointing to const */
    //-elib(844)
    //-e954	/* pointer could be declared pointing to const */
    //-elib(954)
// </c>

/**** Rule 8.14 (Req) ************/
// <!c> Rule 8.14 (required): The restrict type qualifier shall not be used
	//-esym(586, restrict)
// </c>
// </h>

// <h> Rules 9.x: Initialization
/**** Rule 9.1 (Mand) ************/
// <!c> Rule 9.1 (mandatory): The value of an object with automatic storage duration shall not be read before it has been set
    //-e644                   /* Symbol may not have been initialized */
    //-elib(644)
    //-e771                   /* Symbol conceivably not initialized */
    //-elib(771)
    //-e530                   /* Symbol not initialized */
    //-elib(530)
// </c>

/**** Rule 9.2 (Req) ************/
// <!c> Rule 9.2 (required): The initializer for an aggregate or union shall be enclosed in braces
    //-e9069                  /* omitted braces within an initializer */
    //-elib(9069)
// </c>

/**** Rule 9.3 (Req) ************/
// <!c> Rule 9.3 (required): Arrays shall not be partially initialized
    //-e9068                  /* too few initializers */
    //-elib(9068)
// </c>

/**** Rule 9.4 (Req) ************/
// <!c> Rule 9.4 (required): An element of an object shall not be initialized more than once
    //-e485                               /* duplicate initialization */
    //-elib(485)
// </c>

/**** Rule 9.5 (Req) ************/
// <!c> Rule 9.5 (required): Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly
    //-e9054                              /* designated initializer and dimensionless array */
    //-elib(9054)
// </c>
// </h>

// <h> Rules 10.x: The essential type model
/**** Rule 10.1 (Req) ************/
// <!c> Rule 10.1 (required): Operands shall not be of an inappropriate essential type
    //-e48				/* bad type */
    //-elib(48)
    //-e9027                              /* unpermitted operand */
    //-elib(9027)
// </c>

/**** Rule 10.2 (Req) ************/
// <!c> Rule 10.2 (required): Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations
    //-e9028                              /* unpermitted arithmetic */
    //-elib(9028)
// </c>

/**** Rule 10.3 (Req) ************/
// <!c> Rule 10.3 (required): The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category
    //-e9034                              /* expression assigned to narrower or different essential type */
    //-elib(9034)
// </c>

/**** Rule 10.4 (Req) ************/
// <!c>Rule 10.4 (required): Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category
    //-e9029                              /* mismatched essential type */
    //-elib(9029)
// </c>

/**** Rule 10.5 (Adv) ************/
// <!c> Rule 10.5 (advisory): The value of an expression should not be cast to an inappropriate essential type
    //-e9030                              /* impermissible cast */
    //-elib(9030)
// </c>

/**** Rule 10.6 (Req) ************/
// <!c> Rule 10.6 (required): The value of a composite expression shall not be assigned to an object with wider essential type
    //-e9031                              /* composite expression assigned to wider essential type */
    //-elib(9031)
// </c>

/**** Rule 10.7 (Req) ************/
// <!c> Rule 10.7 (required): If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type
    //-e9032                              /* composite expression with smaller essential type than other operand*/
    //-elib(9032)
// </c>

/**** Rule 10.8 (Req) ************/
// <!c> Rule 10.8 (required): The value of a composite expression shall not be cast to a different essential type category or a wider essential type
    //-e9033                              /* impermissible cast of composite expression */
    //-elib(9033)
// </c>
// </h>

// <h> Rules 11.x: Pointer type conversions
/**** Rule 11.1 (Req) ************/
// <!c> Rule 11.1 (required): Conversions shall not be performed between a pointer to a function and any other type
    //-e9074                   /* conversion between a pointer to function and another type */
    //-elib(9074)
// </c>

/**** Rule 11.2 (Req) ************/
// <!c> Rule 11.2 (required): Conversions shall not be performed between a pointer to an incomplete type and any other type
    //-e9076                   /* conversion between a pointer to incomplete type and another type */
    //-elib(9076)
// </c>

/**** Rule 11.3 (Req) ************/
// <!c> Rule 11.3 (required): A cast shall not be performed between a pointer to object type and a pointer to a different object type
    //-e9087         /* cast from pointer to pointer */
    //-elib(9087)
// </c>

/**** Rule 11.4 (Adv) ************/
// <!c> Rule 11.4 (advisory): A conversion should not be performed between a pointer to object and an integer type
    //-e9078                        /* cast pointer/integer */
    //-elib(9078)
// </c>

/**** Rule 11.5 (Adv) ************/
// <!c> Rule 11.5 (advisory): A conversion should not be performed from pointer to void into pointer to object
    //-e9079         /* cast from pointer to pointer */
    //-elib(9079)
// </c>

/**** Rule 11.6 (Req) ************/
// <!c> Rule 11.6 (required): A cast shall not be performed between pointer to void and an arithmetic type
    //-e923                        /* cast pointer/non-pointer */
    //-elib(923)
// </c>

/**** Rule 11.7 (Req) ************/
// <!c> Rule 11.7 (required): A cast shall not be performed between pointer to object and a non-integer arithmetic type
    //-e68                        /* cast pointer/float */
    //-elib(68)
    //-e70                        /* cast pointer/float */
    //-elib(70)
// </c>

/**** Rule 11.8 (Req) ************/
// <!c> Rule 11.8 (required): A cast shall not remove any const or volatile qualification from the type pointed to by a pointer
    //-e9005                              /* attempt to cast away const/volatile from pointer or reference */
    //-elib(9005)
// </c>

/**** Rule 11.9 (Req) ************/
// <!c> Rule 11.9 (required): The macro NULL shall be the only permitted form of integer null pointer constant
    //-e910       /* conversion from 0 to pointer */
    //-elib(910)
    //-e9080      /* integer null pointer constant */
    //-elib(9080)
// </c>
// </h>

// <h> Rules 12.x: Expressions
/**** Rule 12.1 (Adv) ************/
// <!c> Rule 12.1 (advisory): The precedence of operators within expressions should be made explicit
    //-e9050        /* dependence placed on precedence */
    //-elib(9050)
// </c>

/**** Rule 12.2 (Req) ************/
// <!c> Rule 12.2 (required): The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand
    //-e598           /* excessive left shift */
    //-elib(598)
    //-e9053          /* shift value exceeds size of LHS */
    //-elib(9053)
// </c>

/**** Rule 12.3 (Adv) ************/
// <!c> Rule 12.3 (advisory): The comma operator should not be used
    //-e9008                              /* comma operator used */
    //-elib(9008)
// </c>

/**** Rule 12.4 (Adv) ************/
// <!c> Rule 12.4 (advisory): Evaluation of constant expressions should not lead to unsigned integer wrap-around
    //-e648
    //-elib(648)      /* Overflow in computing constant */
    //-estring(648,"unsigned addition")
    //-estring(648,"unsigned multiplication")
    //-estring(648,"unsigned sub.")
    //-estring(648,"unsigned shift left")
    //-estring(648,"unsigned shift right")
// </c>
// </h>

// <h> Rules 13.x: Side effects
/**** Rule 13.1 (Req) ************/
// <!c> Rule 13.1 (required): Initializer lists shall not contain persistent side effects
    //-e446                              /* side effect in initializer */
    //-elib(446)
// </c>

/**** Rule 13.2 (Req) ************/
// <!c> Rule 13.2 (required): The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders
    //-e564			/* variable depends on order of evaluation */
    //-elib(564)
    //-e864			/* variable possibly depends on order of evaluation */
    //-elib(864)
    //-e931	       	    	/* both sides have side effects */
    //-elib(931)
// </c>

/**** Rule 13.3 (Adv) ************/
// <!c> Rule 13.3 (advisory): A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator
    //-e9049                              /* increment/decrement combined with other operations */
    //-elib(9049)
// </c>

/**** Rule 13.4 (Adv) ************/
// <!c> Rule 13.4 (advisory): The result of an assignment operator should not be used
    //-e720                    /* Boolean test of assignment */
    //-elib(720)
    //-e820                    /* Boolean test of parenthesized assignment */
    //-elib(820)
    //-e9084                   /* assignment used inside larger expression */
    //-elib(9084)
// </c>

/**** Rule 13.5 (Req) ************/
// <!c> Rule 13.5 (required): The right hand operand of a logical && or || operator shall not contain persistent side effects
    //-e9007                              /* side effects on right hand side of logical operator */
    //-elib(9007)
// </c>

/**** Rule 13.6 (Mand) ************/
// <!c> Rule 13.6 (mandatory): The operand of the sizeof operator shall not contain any expression which has potential side effects
    //-e9006                              /* sizeof used with expression with side effect */
    //-elib(9006)
    //-e9089                              /* potential side-effect in argument to sizeof */
    //-elib(9089)
// </c>
// </h>

// <h> Rules 14.x: Control statement expressions
/**** Rule 14.1 (Req) ************/
// <!c> Rule 14.1 (required): A loop counter shall not have essentially floating type
    //-e9009                              /* floating point variable used as loop counter */
    //-elib(9009)
// </c>

/**** Rule 14.2 (Req) ************/
// <!c> Rule 14.2 (required): A for loop shall be well-formed
    //-e850           /* index variable modified in body of for loop */
    //-elib(850)
// </c>

/**** Rule 14.3 (Req) ************/
// <!c> Rule 14.3 (required): Controlling expressions shall not be invariant
    //-e685			/* relational always evaluates to true/false */
    //-elib(685)
    //-e774			/* boolean always evaluates to true/false */
    //-elib(774)
    //-e650			/* constant out of range for operator */
    //-elib(650)
// </c>

/**** Rule 14.4 (Req) ************/
// <!c> Rule 14.4 (required): The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type
    //-e9036                              /* condition should have essentially Boolean type */
    //-elib(9036)
// </c>
// </h>

// <h> Rules 15.x: Control flow
/**** Rule 15.1 (Adv) ************/
// <!c> Rule 15.1 (advisory): The goto statement should not be used
    //-e801       /* use of 'goto' is deprecated */
    //-elib(801)
// </c>

/**** Rule 15.2 (Req) ************/
// <!c> Rule 15.2 (required): The goto statement shall jump to a label declared later in the same function
    //-e9064      /* goto references earlier label */
    //-elib(9064)
// </c>

/**** Rule 15.3 (Req) ************/
// <!c> Rule 15.3 (required): Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement
    //-e9041                      /* goto not nested in the same block as label */
    //-elib(9041)
// </c>

/**** Rule 15.4 (Adv) ************/
// <!c> Rule 15.4 (advisory): There should be no more than one break or goto statement used to terminate any iteration statement
    //-e9011                              /* more than one 'break' terminates loop */
    //-elib(9011)
// </c>

/**** Rule 15.5 (Adv) ************/
// <!c> Rule 15.5 (advisory): A function should have a single point of exit at the end
    //-e904                   /* return before function end */
    //-elib(904)
// </c>

/**** Rule 15.6 (Req) ************/
// <!c> Rule 15.6 (required): The body of an iteration-statement or a selection-statement shall be acompound-statement
    //-e9012                   /* sub-statement should be a compound statement */
    //-elib(9012)
// </c>

/**** Rule 15.7 (Req) ************/
// <!c> Rule 15.7 (required): All if ... else if constructs shall be terminated with an else statement
    //-e9013                   /* no 'else' at end of 'if ... else if' chain */
    //-elib(9013)
    //-e9063                   /* no comment or action in else-branch */
    //-elib(9063)
// </c>
// </h>

// <h> Rules 16.x: Switch statements
/**** Rule 16.1 (Req) ************/
// <!c> Rule 16.1 (required): All switch statements shall be well-formed
    //-e616                  /* control flows into case/default */
    //-elib(616)
    //-e744                  /* switch statement has no default */
    //-elib(744)
    //-e764                  /* switch does not have a case */
    //-elib(764)
    //-e825                  /* control flows into case/default without -fallthrough comment */
    //-elib(825)
    //-e9014                 /* default missing from switch */
    //-elib(9014)
    //-e9042                 /* departure from MISRA switch syntax */
    //-elib(9042)
    //-e9077                 /* missing unconditional break */
    //-elib(9077)
    //-e9081                 /* too few independent cases for switch */
    //-elib(9081)
    //-e9082                 /* switch statement should either begin or end with default label */
    //-elib(9082)
    //-e9085                 /* statement or comment should appear in default case */
    //-elib(9085)
// </c>

/**** Rule 16.2 (Req) ************/
// <!c> Rule 16.2 (required): A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
    //-e44                  /* Need a switch */
    //-elib(44)
    //-e9055                /* enclosing statement is not a switch */
    //-elib(9055)
// </c>

/**** Rule 16.3 (Req) ************/
// <!c> Rule 16.3 (required): An unconditional break statement shall terminate every switch-clause
    //-e616                 /* control flows into case/default */
    //-elib(616)
    //-e825                 /* control flows into case/default without -fallthrough comment */
    //-elib(825)
    //-e9077                /* missing unconditional break */
    //-elib(9077)
    //-e9090                /* missing unconditional break */
    //-elib(9090)
// </c>

/**** Rule 16.4 (Req) ************/
// <!c> Rule 16.4 (required): Every switch statement shall have a default label
    //-e744            /* switch statement has no default */
    //-elib(744)
    //-e9014            /* switch statement has no default */
    //-elib(9014)
    //-e9085            /* default case has no statement nor comment */
    //-elib(9085)
// </c>

/**** Rule 16.5 (Req) ************/
// <!c> Rule 16.5 (required): A default label shall appear as either the first or the last switch label of a switch statement
    //-e9082                   /* default should be first or last */
    //-elib(9082)
// </c>

/**** Rule 16.6 (Req) ************/
// <!c> Rule 16.6 (required): Every switch statement shall have at least two switch-clauses
    //-e764            /* switch does not have a case */
    //-elib(764)
    //-e9081           /* too few cases */
    //-elib(9081)
// </c>

/**** Rule 16.7 (Req) ************/
// <!c> Rule 16.7 (required): A switch-expression shall not have essentially Boolean type
    //-e483                   /* boolean value in switch expression */
    //-elib(483)
// </c>
// </h>

// <h> Rules 17.x: Functions
/**** Rule 17.1 (Req) ************/
// <!c> Rule 17.1 (required): The features of <stdarg.h> shall not be used
    //-efile(829, stdarg.h)
    //-esym(586, va_arg)
    //-esym(586, va_start)
    //-esym(586, va_end)
    //-esym(586, va_copy)
// </c>

/**** Rule 17.2 (Req) ************/
// <!c> Rule 17.2 (required): Functions shall not call themselves, either directly or indirectly
    //-e9070
// </c>

/**** Rule 17.3 (Mand) ************/
// <!c> Rule 17.3 (mandatory): A function shall not be declared implicitly
    //-e718  	      		 /* symbol undeclared, assumed to return int */
    //-elib(718)
// </c>

/**** Rule 17.4 (Mand) ************/
// <!c> Rule 17.4 (mandatory): All exit paths from a function with non-void return type shall have an explicit return statement with an expression
    //-e533                /* function should return a value */
    //-elib(533)
// </c>

/**** Rule 17.5 (Adv) ************/
// <n> Rule 17.5 (advisory): The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements
//  <i> *** NOT CHECKED *** MISRA has declared this rule to be "undecidable"

/**** Rule 17.6 (Mand) ************/
// <!c> Rule 17.6 (mandatory): The declaration of an array parameter shall not contain the static keyword between the [ ]
    //-e9043                   /* static between brackets of array declaration */
    //-elib(9043)
// </c>

/**** Rule 17.7 (Req) ************/
// <!c> Rule 17.7 (required): The value returned by a function having non-void return type shall be used
    //-e534               /* ignoring return value of function */
    //-elib(534)
// </c>

/**** Rule 17.8 (Adv) ************/
// <!c> Rule 17.8 (advisory): A function parameter should not be modified
    //-e9044               /* function parameter modified */
    //-elib(9044)
// </c>
// </h>

// <h> Rules 18.x: Pointers and arrays
/**** Rule 18.1 (Req) ************/
// <!c> Rule 18.1 (required): A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand
    //-e415          /* out-of-bounds pointer */
    //-elib(415)
    //-e416          /* out-of-bounds pointer */
    //-elib(416)
    //-e428          /* out-of-bounds pointer */
    //-elib(428)
    //-e661          /* out-of-bounds pointer */
    //-elib(661)
    //-e662          /* out-of-bounds pointer */
    //-elib(662)
    //-e676          /* out-of-bounds pointer */
    //-elib(676)
    //-e796          /* out-of-bounds pointer */
    //-elib(796)
    //-e797          /* out-of-bounds pointer */
    //-elib(797)
    //-e817          /* out-of-bounds pointer */
    //-elib(817)
// </c>

/**** Rule 18.2 (Req) ************/
// <!c> Rule 18.2 (required): Subtraction between pointers shall only be applied to pointers that address elements of the same array
    //-e946          /* relational or subtract operator applied to pointers */
    //-elib(946)
    //-e947          /* relational or subtract operator applied to pointers */
    //-elib(947)
// </c>

/**** Rule 18.3 (Req) ************/
// <!c> Rule 18.3 (required): The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object
    //-e946          /* relational or subtract operator applied to pointers */
    //-elib(946)
    //-e947          /* relational or subtract operator applied to pointers */
    //-elib(947)
// </c>

/**** Rule 18.4 (Adv) ************/
// <!c> Rule 18.4 (advisory):  The +, -, += and -= operators should not be applied to an expression of pointer type
    //-e9016                   /* pointer arithmetic other than array indexing used */
    //-elib(9016)
// </c>

/**** Rule 18.5 (Adv) ************/
// <!c> Rule 18.5 (advisory): Declarations should contain no more than two levels of pointer nesting
    //-e9025                   /* more than two pointer indirection levels used */
    //-elib(9025)
// </c>

/**** Rule 18.6 (Req) ************/
// <!c> Rule 18.6 (required): The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist
    //-e733               /* assigning address of auto to outer scope symbol */
    //-elib(733)
    //-e789               /* assigning address of auto to static */
    //-elib(789)
    //-e604               /* returning address of auto variable */
    //-elib(604)
// </c>

/**** Rule 18.7 (Req) ************/
// <!c> Rule 18.7 (required): Flexible array members shall not be declared
    //-e9038                   /* flexible array member declared */
    //-elib(9038)
// </c>

/**** Rule 18.8 (Req) ************/
// <!c> Rule 18.8 (required): Variable-length array types shall not be used
    //-e9035                   /* variable length array declared */
    //-elib(9035)
// </c>
// </h>

// <h> Rules 19.x: Overlapping storage
/**** Rule 19.1 (Mand) ************/
// <n> Rule 19.1 (mandatory): An object shall not be assigned or copied to an overlapping object
//  <i> *** NOT CHECKED *** MISRA has declared this rule to be "undecidable"

/**** Rule 19.2 (Adv) ************/
// <!c> Rule 19.2 (advisory): The union keyword should not be used
    //-e9018                   /* union type/object declared */
    //-elib(9018)
// </c>
// </h>

// <h> Rules 20.x: Preprocessing directives
/**** Rule 20.1 (Adv) ************/
// <!c> Rule 20.1 (advisory): #include directives should only be preceded by preprocessor directives or comments
    //-e9019                   /* declaration before #include */
    //-elib(9019)
// </c>

/**** Rule 20.2 (Req) ************/
// <!c> Rule 20.2 (required): The ',' or characters and the /* or // character sequences shall not occur in a header file name
    //-e9020                   /* header file name with non-standard character */
    //-elib(9020)
// </c>

/**** Rule 20.3 (Req) ************/
// <!c> Rule 20.3 (required): The #include directive shall be followed by either a <filename> or "filename" sequence
    //-e12                    /* Need LT or " after #include */
    //-elib(12)
    //-e9086                    /* multiple arguments after #include */
    //-elib(9086)
// </c>

/**** Rule 20.4 (Req) ************/
// <!c> Rule 20.4 (required): A macro shall not be defined with the same name as a keyword
    //-e9051                              /* macro with same name as a keyword */
    //-elib(9051)
// </c>

/**** Rule 20.5 (Adv) ************/
// <!c> Rule 20.5 (advisory): #undef should not be used
    //-e9021                   /* use of '#undef' is discouraged */
    //-elib(9021)
// </c>

/**** Rule 20.6 (Req) ************/
// <!c> Rule 20.6 (required): Tokens that look like a preprocessing directive shall not occur within a macro argument
    //-e436   /* preprocessor directive in invocation of macro */
    //-elib(436)
// </c>

/**** Rule 20.7 (Req) ************/
// <!c> Rule 20.7 (required): Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses
    //-e665                   /* expression passed to unparenthesized macro */
    //-elib(665)
// </c>

/**** Rule 20.8 (Req) ************/
// <!c> Rule 20.8 (required): The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1
    //-e9037                  /* conditional of #if/#elif does not evaluate to 0 or 1 */
    //-elib(9037)
// </c>

/**** Rule 20.9 (Req) ************/
// <!c> Rule 20.9 (required): All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation
    //-e553   /* Undefined preprocessor variable, assumed 0 */
    //-elib(553)
// </c>

/**** Rule 20.10 (Adv) ************/
// <!c> Rule 20.10 (advisory): The # and ## preprocessor operators should not be used
    //-e9024                   /* '#/##' operators used */
    //-elib(9024)
// </c>

/**** Rule 20.11 (Req) ************/
// <!c> Rule 20.11 (required): A macro parameter immediately following a # operator shall not immediately be followed by a ## operator
    //-e484                   /* stringize operator followed by macro parameter followed by pasting operator */
    //-elib(484)
// </c>

/**** Rule 20.12 (Req) ************/
// <!c> Rule 20.12 (required): A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators
    //-e9015                              /* macro argument is used both with and without '#/##' and is subject to further replacement */
    //-elib(9015)
// </c>

/**** Rule 20.13 (Req) ************/
// <!c> Rule 20.13 (required): A line whose first token is # shall be a valid preprocessing directive
    //-e544       /* endif or else not followed by EOL */
    //-elib(544)
    //-e16        /* # directive not followed by recognizable word */
    //-elib(16)
    ///* other parts of this rule such as a syntax check of the disabled portions of the code do not seem to be statically checkable */
// </c>

/**** Rule 20.14 (Req) ************/
// <!c> Rule 20.14 (required): All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related
    //-e405       /* #if/#ifdef/#ifndef not closed off */
    //-elib(405)
// </c>
// </h>

// <h> Rules 21.x: Standard libraries
/**** Rule 21.1 (Req) ************/
// <!c> Rule 21.1 (required): #define and #undef shall not be used on a reserved identifier or reserved macro name
    //-e136       /* Illegal macro name */
    //-elib(136)
    ///* Undefining standard library macros is covered by rule 20.5.  */
    ///* Defining/redefining reserved/standard identifiers is covered by rules 20.4 and 21.2. */
    //-e9071      /* defined macro reserved to the compiler */
    //-elib(9071)
    //-e9083      /* undefined macro reserved to the compiler */
    //-elib(9083)
// </c>

/**** Rule 21.2 (Req) ************/
// <!c> Rule 21.2 (required): A reserved identifier or macro name shall not be declared
    //-e683       /* complain about #define standard functions */
    //-elib(683)
    ///* Undefining standard library macros is covered by rule 20.5.  */
    ///* Defining/redefining reserved/standard identifiers is covered by rule 20.4 and 21.2. */
// </c>

/**** Rule 21.3 (Req) ************/
// <!c> Rule 21.3 (required): The memory allocation and deallocation functions of <stdlib.h> shall not be used
    //-esym(586, calloc)
    //-esym(586, malloc)
    //-esym(586, realloc)
    //-esym(586, free)
// </c>

/**** Rule 21.4 (Req) ************/
// <!c> Rule 21.4 (required): The standard header file <setjmp.h> shall not be used
    //-efile(829, setjmp.h)
    //-esym(586, setjmp)
    //-esym(586, longjmp)
    //-esym(586, setjmp)
    //-esym(586, longjmp)
// </c>

/**** Rule 21.5 (Req) ************/
// <!c> Rule 21.5 (required): The standard header file <signal.h> shall not be used
    //-efile(829, signal.h)
    //-esym(586, signal)
    //-esym(586, raise)
    //-esym(586, SIGABRT)
    //-esym(586, SIGFPE)
    //-esym(586, SIGILL)
    //-esym(586, SIGINT)
    //-esym(586, SIGSEGV)
    //-esym(586, SIGTERM)
    //-esym(586, SIG_DFL)
    //-esym(586, SIG_ERR)
    //-esym(586, SIG_IGN)
// </c>

/**** Rule 21.6 (required): (Req) ************/
// <!c> Rule 21.6 The Standard Library input/output functions shall not be used
    //-esym(586, clearerr)
    //-esym(586, fclose)
    //-esym(586, feof)
    //-esym(586, ferror)
    //-esym(586, fflush)
    //-esym(586, fgetc)
    //-esym(586, fgetpos)
    //-esym(586, fgets)
    //-esym(586, fgetwc)
    //-esym(586, fgetws)
    //-esym(586, fopen)
    //-esym(586, fprintf)
    //-esym(586, fputc)
    //-esym(586, fputs)
    //-esym(586, fputwc)
    //-esym(586, fputws)
    //-esym(586, fread)
    //-esym(586, fscanf)
    //-esym(586, fseek)
    //-esym(586, fsetpos)
    //-esym(586, freopen)
    //-esym(586, ftell)
    //-esym(586, fwide)
    //-esym(586, fwprintf)
    //-esym(586, fwrite)
    //-esym(586, fwscanf)
    //-esym(586, getc)
    //-esym(586, getchar)
    //-esym(586, gets)
    //-esym(586, getwc)
    //-esym(586, getwchar)
    //-esym(586, perror)
    //-esym(586, printf)
    //-esym(586, putc)
    //-esym(586, putchar)
    //-esym(586, puts)
    //-esym(586, putwc)
    //-esym(586, putwchar)
    //-esym(586, remove)
    //-esym(586, rename)
    //-esym(586, rewind)
    //-esym(586, scanf)
    //-esym(586, setbuf)
    //-esym(586, setvbuf)
    //-esym(586, snprintf)
    //-esym(586, sprintf)
    //-esym(586, sscanf)
    //-esym(586, swprintf)
    //-esym(586, swscanf)
    //-esym(586, tmpfile)
    //-esym(586, tmpnam)
    //-esym(586, ungetc)
    //-esym(586, ungetwc)
    //-esym(586, vfprintf)
    //-esym(586, vfscanf)
    //-esym(586, vfwprintf)
    //-esym(586, vfwscanf)
    //-esym(586, vprintf)
    //-esym(586, vscanf)
    //-esym(586, vsnprintf)
    //-esym(586, vsprintf)
    //-esym(586, vsscanf)
    //-esym(586, vswprintf)
    //-esym(586, vswscanf)
    //-esym(586, vwprintf)
    //-esym(586, vwscanf)
    //-esym(586, wprintf)
    //-esym(586, wscanf)
    //-esym(586, clearerr)
    //-esym(586, fclose)
    //-esym(586, feof)
    //-esym(586, ferror)
    //-esym(586, fflush)
    //-esym(586, fgetc)
    //-esym(586, fgets)
    //-esym(586, fgetpos)
    //-esym(586, fgetwc)
    //-esym(586, fgetws)
    //-esym(586, fopen)
    //-esym(586, fprintf)
    //-esym(586, fputc)
    //-esym(586, fputs)
    //-esym(586, fputwc)
    //-esym(586, fputws)
    //-esym(586, fread)
    //-esym(586, fscanf)
    //-esym(586, fseek)
    //-esym(586, fsetpos)
    //-esym(586, freopen)
    //-esym(586, ftell)
    //-esym(586, fwide)
    //-esym(586, fwprintf)
    //-esym(586, fwrite)
    //-esym(586, fwscanf)
    //-esym(586, getc)
    //-esym(586, getchar)
    //-esym(586, gets)
    //-esym(586, getwc)
    //-esym(586, getwchar)
    //-esym(586, perror)
    //-esym(586, printf)
    //-esym(586, putc)
    //-esym(586, putchar)
    //-esym(586, puts)
    //-esym(586, putwc)
    //-esym(586, putwchar)
    //-esym(586, remove)
    //-esym(586, rename)
    //-esym(586, rewind)
    //-esym(586, scanf)
    //-esym(586, setbuf)
    //-esym(586, setvbuf)
    //-esym(586, snprintf)
    //-esym(586, sprintf)
    //-esym(586, sscanf)
    //-esym(586, swprintf)
    //-esym(586, swscanf)
    //-esym(586, tmpfile)
    //-esym(586, tmpnam)
    //-esym(586, ungetc)
    //-esym(586, ungetwc)
    //-esym(586, vfprintf)
    //-esym(586, vfscanf)
    //-esym(586, vfwprintf)
    //-esym(586, vfwscanf)
    //-esym(586, vprintf)
    //-esym(586, vscanf)
    //-esym(586, vsnprintf)
    //-esym(586, vsprintf)
    //-esym(586, vsscanf)
    //-esym(586, vswprintf)
    //-esym(586, vswscanf)
    //-esym(586, vwprintf)
    //-esym(586, vwscanf)
    //-esym(586, wprintf)
    //-esym(586, wscanf)
// </c>

/**** Rule 21.7 (Req) ************/
// <!c> Rule 21.7 (required): The atof, atoi, atol and atoll functions of <stdlib.h> shall not be used
    //-esym(586, atof)
    //-esym(586, atoi)
    //-esym(586, atol)
    //-esym(586, atoll)
    //-esym(586, atof)
    //-esym(586, atoi)
    //-esym(586, atol)
    //-esym(586, atoll)
// </c>

/**** Rule 21.8 (Req) ************/
// <!c> Rule 21.8 (required): The library functions abort, exit, getenv and system of <stdlib.h> shall not be used
    //-esym(586, abort)
    //-esym(586, exit)
    //-esym(586, getenv)
    //-esym(586, system)
    //-esym(586, abort)
    //-esym(586, exit)
    //-esym(586, getenv)
    //-esym(586, system)
// </c>

/**** Rule 21.9 (Req) ************/
// <!c> Rule 21.9 (required): The library functions bsearch and qsort of <stdlib.h> shall not be used
    //-esym(586, bsearch)
    //-esym(586, qsort)
    //-esym(586, bsearch)
    //-esym(586, qsort)
// </c>

/**** Rule 21.10 (Req) ************/
// <!c> Rule 21.10 (required): The Standard Library time and date functions shall not be used
    //-efile(829, time.h)
    //-esym(586, wcsftime)
    //-esym(586, wcsftime)
    //-esym(586, clock)
    //-esym(586, clock)
    //-esym(586, difftime)
    //-esym(586, difftime)
    //-esym(586, mktime)
    //-esym(586, mktime)
    //-esym(586, time)
    //-esym(586, time)
    //-esym(586, asctime)
    //-esym(586, asctime)
    //-esym(586, ctime)
    //-esym(586, ctime)
    //-esym(586, gmtime)
    //-esym(586, gmtime)
    //-esym(586, localtime)
    //-esym(586, localtime)
    //-esym(586, strftime)
    //-esym(586, strftime)
    //-esym(586, CLOCKS_PER_SEC)
// </c>

/**** Rule 21.11 (Req) ************/
// <!c> Rule 21.11 (required): The standard header file <tgmath.h> shall not be used
    //-efile(829, tgmath.h)
// </c>

/**** Rule 21.12 (Adv) ************/
// <!c> Rule 21.12 (advisory): The exception handling features of <fenv.h> should not be used
    //-esym(586, feclearexcept)
    //-esym(586, feclearexcept)
    //-esym(586, fegetexceptflag)
    //-esym(586, fegetexceptflag)
    //-esym(586, feraiseexcept)
    //-esym(586, feraiseexcept)
    //-esym(586, fesetexceptflag)
    //-esym(586, fesetexceptflag)
    //-esym(586, fetestexcept)
    //-esym(586, fetestexcept)
    //-esym(586, FE_INEXACT)
    //-esym(586, FE_DIVBYZERO)
    //-esym(586, FE_UNDERFLOW)
    //-esym(586, FE_OVERFLOW)
    //-esym(586, FE_INVALID)
    //-esym(586, FE_ALL_EXCEPT)
// </c>
// </h>

// <h> Rules 22.x: Resources
/**** Rule 22.1 (Req) ************/
// <!c> Rule 22.1 (required): All resources obtained dynamically by means of Standard Library functions shall be explicitly released
    //-e429       /* custodial pointer neither free'd nor returned */
    //-elib(429)
    //-e480       /* no balancing call */
    //-elib(480)
    //-e481       /* different balance call states */
    //-elib(481)
// </c>

/**** Rule 22.2 (Mand) ************/
// <!c> Rule 22.2 (mandatory): A block of memory shall only be freed if it was allocated by means of a Standard Library function
    //-e424       /* inappropriate deallocation */
    //-elib(424)
    //-e449       /* pointer previously deallocated */
    //-elib(449)
// </c>

/**** Rule 22.3 (required): (Req) ************/
// <n> Rule 22.3 The same file shall not be open for read and write access at the same time on different streams
//  <i> *** NOT CHECKED *** MISRA has declared this rule to be "undecidable"

/**** Rule 22.4 (Mand) ************/
// <n> Rule 22.4 (mandatory): There shall be no attempt to write to a stream which has been opened as read-only
//  <i> *** NOT CHECKED *** MISRA has declared this rule to be "undecidable"

/**** Rule 22.5 (Mand) ************/
// <!c> Rule 22.5 (mandatory): A pointer to a FILE object shall not be dereferenced
    //-e9047   /* FILE pointer dereferenced */
    //-elib(9047)
// </c>

/**** Rule 22.6 (Mand) ************/
// <!c> Rule 22.6 (mandatory): The value of a pointer to a FILE shall not be used after the associated stream has been closed
    //-e449   /* previously deallocated pointer */
    //-elib(449)
// </c>
// </h>

// </h>

// <<< end of configuration section >>>
