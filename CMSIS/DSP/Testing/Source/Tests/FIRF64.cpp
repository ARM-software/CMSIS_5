#include "FIRF64.h"
#include <stdio.h>
#include "Error.h"

#define SNR_THRESHOLD 310

/* 

Reference patterns are generated with
a double precision computation.

*/
#define REL_ERROR (2.0e-14)


static void checkInnerTail(float64_t *b)
{
    ASSERT_TRUE(b[0] == 0.0);
    ASSERT_TRUE(b[1] == 0.0);
}

// Coef must be padded to a multiple of 4
#define FIRCOEFPADDING 2

    void FIRF64::test_fir_f64()
    {
        

        const int16_t *configp = configs.ptr();
        float64_t *statep = state.ptr();
        const float64_t *orgcoefsp = coefs.ptr();
        
        const float64_t *coefsp;
        const float64_t *inputp = inputs.ptr();

        float64_t *outp = output.ptr();

        unsigned long i;

        int blockSize;
        int numTaps;



        /*

        Python script is generating different tests with
        different blockSize and numTaps.

        We loop on those configs.

        */
        for(i=0; i < configs.nbSamples() ; i += 2)
        {

           blockSize = configp[0];
           numTaps = configp[1];

           coefsp = orgcoefsp;

           /*

           The filter is initialized with the coefs, blockSize and numTaps.

           */
           arm_fir_init_f64(&this->S,numTaps,coefsp,statep,blockSize);

           /*

           Input pointer is reset since the same input pattern is used

           */
           inputp = inputs.ptr();

          
           /*
           
           Python script is filtering a 2*blockSize number of samples.
           We do the same filtering in two pass to check (indirectly that
           the state management of the fir is working.)

           */

           
           arm_fir_f64(&this->S,inputp,outp,blockSize);
           
           outp += blockSize;
           checkInnerTail(outp);
           
           inputp += blockSize;
           arm_fir_f64(&this->S,inputp,outp,blockSize);
           outp += blockSize;
           checkInnerTail(outp);

           configp += 2;
           orgcoefsp += numTaps;

        }


        ASSERT_EMPTY_TAIL(output);

        ASSERT_SNR(output,ref,(float64_t)SNR_THRESHOLD);

        ASSERT_REL_ERROR(output,ref,REL_ERROR);

    } 

 
    void FIRF64::setUp(Testing::testID_t id,std::vector<Testing::param_t>& params,Client::PatternMgr *mgr)
    {
      
       (void)params;
       
       switch(id)
       {
        case FIRF64::TEST_FIR_F64_1:
        break;

       }
      

       inputs.reload(FIRF64::FIRINPUTS_F64_ID,mgr);
       coefs.reload(FIRF64::FIRCOEFS_F64_ID,mgr);
       configs.reload(FIRF64::FIRCONFIGS_S16_ID,mgr);
       ref.reload(FIRF64::FIRREFS_F64_ID,mgr);

       output.create(ref.nbSamples(),FIRF64::OUT_F64_ID,mgr);
       /* Max 2*blockSize + numTaps - 1 as generated by Python script 
          A temp buffer blockSize is used by Helium implementation.
          It is at beginning of state buffer and is NOT the state
          of the FIR which is in the following part.
       */
       state.create(47+47,FIRF64::OUT_F64_ID,mgr);



    }

    void FIRF64::tearDown(Testing::testID_t id,Client::PatternMgr *mgr)
    {
        (void)id;
        output.dump(mgr);
    }
