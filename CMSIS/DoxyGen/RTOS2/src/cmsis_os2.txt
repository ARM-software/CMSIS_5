/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\mainpage

The <b>CMSIS-RTOS API v2</b> addresses the following new requirements:
 - Dynamic object creation no longer requires static memory, static memory buffers are now optional.
 - Support for ARMv8-M architecture that provides a Secure and Non-Secure state of code execution.
 - Provisions for message passing in multi-core systems.
 - Full support of C++ run-time environments.
 - C interface which is binary compatible across <a class="el" href="http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html">ABI compatible compilers</a>.

As a consequence of these requirements the CMSIS-RTOS API v2 has the following fundamental modifications:
 - The functions osXxxxNew replace osXxxxCreate functions; osXxxxNew and osXxxxDelete create and destroy objects.
 - The C function main is not longer started as a thread (this was an optional feature in CMSIS-RTOS v1).
 - Functions that return osEvent have been replaced.

CMSIS-RTOS API v2 provides an translation layer for the
<a class="el" href="../../RTOS/html/index.html">CMSIS-RTOS API v1</a> that simplifies migration.

CMSIS-RTOS API v2 is not POSIX compliant, but has provisions to enable a POSIX translation layer and a C++ interface.
\todo Investigate into a flexible C++ interface and potential POSIX translation

<hr>

CMSIS-RTOS in ARM::CMSIS Pack
-----------------------------

The following files relevant to CMSIS-RTOS are present in the <b>ARM::CMSIS</b> Pack directories:
|File/Folder                  | Content                                                                |
|-----------------------------|------------------------------------------------------------------------|
|\b CMSIS/Documentation/RTOS2 | This documentation                                                     |
|\b CMSIS/Documentation/RTOS  | CMSIS-RTOS API v1 documentation                                 |
|\b CMSIS/RTOS2/Template      | \ref cmsis_os_h                                                        |
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page rtos_revisionHistory Revision History

<table class="cmtable" summary="Revision History">
    <tr>
      <th>Version</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>V2.00</td>
      <td>
        Extended number of thread priorities.\n
        Added: osKernelTime, osKernelStop.\n
        Added: osThreadState, osThreadGetState, osThreadSuspend, osThreadResume.\n
        Added: osTimerRunning.\n
        Added: osPoolDelete.\n
        Added: osMessageCount, osMessageReset, osMessageDelete.\n
        Added: osMailCount, osMailReset, osMailDelete.\n
        Added: osFlag object.\n
     </td>
    </tr>
    <tr>
      <td>V1.02 - only documentation changes</td>
      <td>
      Added: Overview of the \ref rtosValidation "CMSIS-RTOS Validation" Software Pack.\n
	  Clarified: Behavior of \ref CMSIS_RTOS_TimeOutValue.
     </td>
    </tr>
    <tr>
      <td>V1.02</td>
      <td>Added: New control functions for short timeouts in microsecond resolution \b osKernelSysTick,
      \b osKernelSysTickFrequency, \b osKernelSysTickMicroSec.\n
      Removed: osSignalGet.
     </td>
    </tr>
    <tr>
      <td>V1.01</td>
      <td>Added capabilities for C++, kernel initialization and object deletion.\n
      Prepared for C++ class interface. In this context to \em const attribute has been moved from osXxxxDef_t typedefs to
      the osXxxxDef macros.\n
      Added: \ref osTimerDelete, \ref osMutexDelete, \ref osSemaphoreDelete.\n
      Added: \ref osKernelInitialize that prepares the Kernel for object creation.\n
      </td>
    </tr>
    <tr>
      <td>
      V1.00</td>
      <td>First official Release.\n
      Added: \ref osKernelStart; starting 'main' as a thread is now an optional feature.\n
      Semaphores have now the standard behavior.\n
      \b osTimerCreate does no longer start the timer. Added: \ref osTimerStart (replaces osTimerRestart).\n
      Changed: osThreadPass is renamed to \ref osThreadYield.
      </td>
    </tr>
    <tr>
      <td>V0.02</td>
      <td>Preview Release.</td>
    </tr>
</table>
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page usingOS Using a CMSIS-RTOS Implementation

A CMSIS-RTOS implementation is typically provided as a library. To add the RTOS functionality to an existing CMSIS-based
application, the RTOS library (and typically a configuration file) needs to be added. The available functionality of the
RTOS library is defined in the header file \b cmsis_os.h that is specific for each CMSIS-RTOS implementation.

\image html "CMSIS_RTOS_Files.png" "CMSIS-RTOS File Structure"

Depending on the CMSIS-RTOS implementation, execution may start with the \b main function as the first thread. This has the
benefit that an application programmer may use other middleware libraries that create threads internally, but the remaining
part of the user application just uses the \b main thread. Therefore, the usage of the RTOS can be invisible to the
application programmer, but libraries can use CMSIS-RTOS features.

Once the files are added to a project, the user can start working with the CMSIS-RTOS functions. A code example is provided
below:
 
<b>Code Example</b>
\code
#include "cmsis_os.h"                            // CMSIS-RTOS header file
 
void job1 (void const *argument)  {              // thread function 'job1'
  while (1)  {
      :                                          // execute some code
    osDelay (10);                                // delay execution for 10 milliseconds
  }
}
 
osThreadDef(job1, osPriorityAboveNormal, 1, 0);  // define job1 as thread function
 
void job2 (void const *argument)  {              // thread function 'job2'
  osThreadCreate(osThread(job1),NULL);           // create job1 thread
  while (1)   {
    :                                            // execute some code
  }
}
 
osThreadDef(job2, osPriorityNormal, 1, 0);       // define job2 as thread function
 
void job3 (void const *argument)  {              // thread function 'job3'
  while (1)   {
      :                                          // execute some code
    osDelay (20);                                // delay execution for 20 milliseconds
  }
}
 
osThreadDef(job3, osPriorityNormal, 1, 0);       // define job3 as thread function
 
int main (void) {                                // program execution starts here
  osKernelInitialize ();                         // initialize RTOS kernel
    :                                            // setup and initialize peripherals
  osThreadCreate (osThread(job2));
  osThreadCreate (osThread(job3));
  osKernelStart ();                              // start kernel with job2 execution
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page functionOverview Function Overview

CMSIS-RTOS v2 provides multiple API functions:
  - \subpage rtos_api2 is the new C function API that support dynamic object creation, ARMv8-M, and multi-processor
    communication.
  - <a class="el" href="../../RTOSv1/html/_function_overview.html">CMSIS-RTOS C API Version 1</a> is a C function API the is
    backward compatible with CMSIS-RTOS v2.
  - \subpage rtos_apicpp is a C++ class function API.

It is possible to intermix the different API variants in the same application and even in the same C/C++ source module.
However, the functions of the <b>C API Version 1</b> may be deprecated in future versions of CMSIS-RTOS.

\section CMSIS_RTOS_TimeOutValue Timeout Value   

The timeout value specifies the number of timer ticks until a timeout or time delay elapses. The value is an upper bound and 
depends on the actual time elapsed since the last timer tick. 

For a value of \b 1 the system waits until the next timer tick occurs. That means that the actual timeout value can be one
timer tick less than the specified timeout value. 

\image html TimerValues.png "Timer Values"

\section CMSIS_RTOS_ISR_Calls Calls from Interrupt Service Routines 

\todo Can any of the new functions be called from ISRs?

The following CMSIS-RTOS functions can be called from threads and Interrupt Service Routines (ISR):
  - \ref osKernelRunning
  - \ref osSemaphoreRelease
  - \ref osMemoryPoolAlloc, \ref osMemoryPoolFree
  - \ref osMessageQueuePut, \ref osMessageQueueGet

Functions that cannot be called from an ISR are verifying the interrupt status and return, in case they are called
from an ISR context, the status code \b osErrorISR. In some implementations, this condition might be caught using the HARD
FAULT vector.

Some CMSIS-RTOS implementations support CMSIS-RTOS function calls from multiple ISRs at the same time.
If this is impossible, the CMSIS-RTOS rejects calls by nested ISR functions with the status code \b osErrorISRRecursive.
*/



/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page rtos_api2 CMSIS-RTOS C API Version 2  

Overview of all CMSIS-RTOS C API v2 functions.

 - \ref CMSIS_RTOS_KernelCtrl
   - \ref osKernelInitialize : Initialize the RTOS kernel for creating objects.
   - \ref osKernelStart : Start the RTOS kernel scheduler.
   - \ref osKernelSuspend : Suspend the RTOS Kernel scheduler.
   - \ref osKernelResume : Resume the RTOS Kernel scheduler.

 - \ref CMSIS_RTOS_ThreadMgmt
   - \ref osThreadNew : Create and start execution of a thread function.
   - \ref osThreadTerminate : Stop execution of a thread function.
   - \ref osThreadSuspend : Suspend a thread function.
   - \ref osThreadResume : Resume a thread function.
   - \ref osThreadGetState : Get current state of an active thread.
   - \ref osThreadYield : Pass execution to next ready thread function.
   - \ref osThreadGetId : Get the thread identifier to reference this thread.
   - \ref osThreadSetPriority : Change the execution priority of a thread function.
   - \ref osThreadGetPriority : Obtain the current execution priority of a thread function.

 - \ref CMSIS_RTOS_Wait
   - \ref osDelay : Wait for a specified time.
   - \ref osDelayUntil : Wait until a specified kernel time.

 - \ref CMSIS_RTOS_TimerMgmt
   - \ref osTimerNew : Create and define timer with related callback function.
   - \ref osTimerDelete : Step a timer and remove related callback function.
   - \ref osTimerStart : Start or restart the timer with a time value.
   - \ref osTimerStop : Stop the timer.
   - \ref osTimerIsRunning : Check if a timer is running.

 - \ref CMSIS_RTOS_ThreadFlagsMgmt
   - \ref osThreadFlagsSet : Set the specified Thread Flags of an active thread
   - \ref osThreadFlagsClear : Clear the specified Thread Flags of an active thread
   - \ref osThreadFlagsGet : Get the current Thread Flags of an active thread.
   - \ref osThreadFlagsWait : Wait for one or more Thread Flags of the current running thread to become signaled

 - \ref CMSIS_RTOS_EventFlags
   - \ref osEventFlagsNew : Create and initialize an Event Flags object.
   - \ref osEventFlagsDelete : Delete an Event Flags object.
   - \ref osEventFlagsSet : Set the specified Event Flags.
   - \ref osEventFlagsClear : Clear the specified Event Flags.
   - \ref osEventFlagsGet : Get the current Event Flags. 
   - \ref osEventFlagsWait : Wait for one or more Event Flags to become signalled.

 - \ref CMSIS_RTOS_MutexMgmt
   - \ref osMutexNew : Create and initialize a Mutex object.
   - \ref osMutexDelete : Delete a Mutex object
   - \ref osMutexAcquire : Obtain a Mutex or Wait until it becomes available.
   - \ref osMutexRelease : Release a MMutex.

 - \ref CMSIS_RTOS_SemaphoreMgmt
   - \ref osSemaphoreNew : Create and initialize a Semaphore object
   - \ref osSemaphoreDelete : Delete a Semaphore object.
   - \ref osSemaphoreAcquire : Obtain a Semaphore token or Wait until it becomes available.
   - \ref osSemaphoreRelease : Release a Semaphore token.
     \todo do we need a function that retrieves how many semaphores are available?

 - \ref CMSIS_RTOS_PoolMgmt
   - \ref osMemoryPoolNew : Define and initialize a fix-size memory pool.
   - \ref osMemoryPoolAlloc : Allocate a memory block.
   - \ref osMemoryPoolFree : Return a memory block to the memory pool.
   - \ref osMemoryPoolDelete : Delete a Memory Pool object

 - \ref CMSIS_RTOS_Message
   - \ref osMessageQueueNew : Create and initialize a message queue.
   - \ref osMessageQueuePut : Put a message into a message queue.
   - \ref osMessageQueueGet : Get a message or suspend thread execution until message arrives.
   - \ref osMessageQueueReset : Reset a Message Queue to initial empty state.
   - \ref osMessageQueueDelete : Delete a Message Queue object.
*/


/*
 - \ref CMSIS_RTOS_Mail
   - \ref osMailQueueNew : Create and Initialize a Mail Queue object.
   - \ref osMailQueueAlloc : Allocate a memory block for mail from a mail memory pool.
   - \ref osMailQueuePut : Put a Mail into a Queue.
   - \ref osMailQueueGet : Get a Mail from a Queue or timeout if Queue is empty.
   - \ref osMailQueueFree : Free a memory block by returning it to a mail memory pool.
   - \ref osMailQueueGetInfo : Get a Mail Queue information.
   - \ref osMailQueueReset : Reset a Mail Queue to initial empty state.
   - \ref osMailQueueDelete : Delete a Mail Queue object.
*/



/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page rtos_apicpp CMSIS-RTOS C++ API

Coming soon
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page cmsis_os_h Header File Template: cmsis_os.h

The file \b cmsis_os.h is a template header file for a CMSIS-RTOS compliant Real-Time Operating System (RTOS).
Each RTOS that is compliant with CMSIS-RTOS shall provide a specific \b cmsis_os.h header file that represents
its implementation.

The file cmsis_os.h contains:
 - CMSIS-RTOS API function definitions
 - struct definitions for parameters and return types
 - status and priority values used by CMSIS-RTOS API functions
 - macros for defining threads and other kernel objects


<b>Name conventions and header file modifications</b>

All definitions are prefixed with \b os to give an unique name space for CMSIS-RTOS functions.
Definitions that are prefixed \b os_ are not used in the application code but local to this header file.
All definitions and functions that belong to a module are grouped and have a common prefix, i.e. \b osThread.

Definitions that are marked with <b>CAN BE CHANGED</b> can be adapted towards the needs of the actual CMSIS-RTOS
implementation. These definitions can be specific to the underlying RTOS kernel.

Definitions that are marked with <b>MUST REMAIN UNCHANGED</b> cannot be altered. Otherwise the CMSIS-RTOS implementation is
no longer compliant to the standard. Note that some functions are optional and need not to be provided by every CMSIS-RTOS
implementation.

<b>Define and reference object definitions</b>

With <b>\#define osObjectsExternal</b> objects are defined as external symbols. This allows to create a consistent header
file that is used throughout a project as shown below:

<i>Header File</i>
\code
#include <cmsis_os.h>                                         // CMSIS RTOS header file

// Thread definition
extern void thread_sample (void const *argument);             // function prototype
osThreadDef (thread_sample, osPriorityBelowNormal, 1, 100);

// Pool definition
osPoolDef(MyPool, 10, long);
\endcode


This header file defines all objects when included in a C/C++ source file. When <b>\#define osObjectsExternal</b> is
present before the header file, the objects are defined as external symbols. A single consistent header file can therefore be
used throughout the whole project.

<i>Example</i>
\code
#include "osObjects.h"     // Definition of the CMSIS-RTOS objects
\endcode

\code
#define osObjectsExternal  // Objects will be defined as external symbols
#include "osObjects.h"     // Reference to the CMSIS-RTOS objects
\endcode

<b>Header file %cmsis_os.h</b>

\include Template/cmsis_os.h
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page rtosValidation RTOS Validation

ARM offers a <a class=el href="http://www.keil.com/pack" target="_blank">Software Pack</a> for the CMSIS-RTOS Validation.
The <b>ARM::CMSIS-RTOS_Validation</b> Pack contains the following:

 - Source code of a CMSIS-RTOS Validation Suite along with configuration file.
 - Documentation of the CMSIS-RTOS Validation Suite.
 - Example that shows the usage of the CMSIS-RTOS Validation Suite using simulation.

The CMSIS-RTOS Validation Suite is currently available in beta release and performs generic validation of various
RTOS features. The test cases verify the functional behavior, test invalid parameters and call management 
functions from ISR.

The following CMSIS-RTOS features can be tested with the current release:
 - Thread : Create multiple threads, terminate, restart, yield, change priority 
 - Timer : Create periodic and one-shot timers
 - GenWait : Call generic wait functions (osDelay and osWait)
 - WaitFunc : Measure wait ticks (delay, mail, message, mutex, semaphore, signal)
 
Moreover the following inter-thread communication functions can be tested: 
 - Signal : Verify signal events
 - Memory Pool : Verify memory allocation
 - Message Queue : Exchange messages between threads
 - Mail Queue : Exchange data between threads
 - Mutex : Synchronize resource access 
 - Semaphore : Access shared resources 
 
The RTOS Validation output can be printed to a console, output via ITM printf, or output to a memory buffer.
 
\section test_output Sample Test Output
\verbatim
CMSIS-RTOS Test Suite   Oct 21 2015   16:39:16 

TEST 01: TC_ThreadCreate                  PASSED
TEST 02: TC_ThreadMultiInstance           PASSED
TEST 03: TC_ThreadTerminate               PASSED
  :
  :
TEST 08: TC_ThreadChainedCreate           PASSED
TEST 09: TC_ThreadYield                   NOT EXECUTED
TEST 10: TC_ThreadParam                   PASSED
  :
  :
TEST 60: TC_MailFromISRToThread           PASSED

Test Summary: 60 Tests, 59 Executed, 59 Passed, 0 Failed, 0 Warnings.
Test Result: PASSED
\endverbatim
*/

/* ========================================================================================================================== */
// Reference 
/** 
 * \addtogroup CMSIS_RTOS CMSIS-RTOS API v2
 * \brief This section describes the CMSIS-RTOS API v2. 
 * \details The CMSIS-RTOS is a generic API layer that interfaces to an existing RTOS kernel.
 *  @{
 */

/// @} 


typedef struct osVersion_s {
  uint32_t                       api;   ///< API version (major.minor.rev: mmnnnrrrr dec).
  uint32_t                    kernel;   ///< Kernel version (major.minor.rev: mmnnnrrrr dec).
} osVersion_t;
 


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Kernel Control ====
/** 
\addtogroup CMSIS_RTOS_KernelCtrl Kernel Information and Control
\ingroup CMSIS_RTOS
\brief Provide version/system information and start the RTOS Kernel.
\details 
The Kernel Information and Control function group allows to:
  - obtain information about the system and the underlying kernel.
  - obtain version information about the CMSIS-RTOS API.
  - initialize of the RTOS kernel for creating objects.
  - start the RTOS kernel and thread switching.
  - check the execution status of the RTOS kernel.

The function \b main is a special thread function that may be started at system initialization. In this case it has the
initial priority \a osPriorityNormal.

When reaching \b main, it is necessary to:
-# Call osKernelInitialize() to initialize the CMSIS-RTOS Kernel
-# Setup device peripherals and create other RTOS objects using the \b os*Create functions.
-# Start the Kernel and begin thread switching by calling osKernelStart().

<b>Code Example</b>
\code
int main (void) {
  osKernelInitialize ();                    // initialize CMSIS-RTOS
 
  // initialize peripherals here
 
  // create 'thread' functions that start executing,
  // example: tid_name = osThreadCreate (osThread(name), NULL);
 
  osKernelStart ();                         // start thread execution 
}
\endcode
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\enum osKernelState_t

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osKernelInitialize (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osKernelState_t osKernelGetState (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osKernelStart (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t osKernelLock (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void osKernelUnlock (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t osKernelSuspend (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void osKernelResume (uint32_t sleep_time)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint64_t osKernelGetTime (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t osKernelGetTick (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t osKernelTickMicroSec (uint32_t microsec)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Thread Management ====
/** 
\addtogroup CMSIS_RTOS_ThreadMgmt Thread Management
\ingroup CMSIS_RTOS CMSIS_RTOSv2
\brief Define, create, and control thread functions.
\details 
The Thread Management function group allows defining, creating, and controlling thread functions in the system. The function
\b main is a special thread function that is started at system initialization and has the initial priority
\a osPriorityNormal.

\anchor ThreadStates
Threads can be in the following states:
 - \b RUNNING: The thread that is currently running is in the \b RUNNING state. Only one thread at a time can be in this
   state.
 - \b READY: Threads which are ready to run are in the \b READY state. Once the \b RUNNING thread has terminated or is
   \b WAITING, the next \b READY thread with the highest priority becomes the \b RUNNING thread.
 - \b WAITING: Threads that are waiting for an event to occur are in the \b WAITING state.
 - \b INACTIVE: Threads that are not created or terminated are in the \b INACTIVE state. These threads typically consume no
   system resources.

\image html "ThreadStatus.png" "Thread State and State Transitions"

A CMSIS-RTOS assumes that threads are scheduled as shown in the figure <b>Thread State and State Transitions</b>. The thread
states change as follows:
 - A thread is created using the function \ref osThreadNew. This puts the thread into the \b READY or \b RUNNING state
   (depending on the thread priority).
 - CMSIS-RTOS is pre-emptive. The active thread with the highest priority becomes the \b RUNNING thread provided it does not
   wait for any event. The initial priority of a thread is defined with the \ref osThreadAttr_t but may be changed during
   execution using the function \ref osThreadSetPriority.
 - The \b RUNNING thread transfers into the \b WAITING state when it is waiting for an event.
 - Active threads can be terminated any time using the function \ref osThreadTerminate. Threads can terminate also by just
   returning from the thread function. Threads that are terminated are in the \b INACTIVE state and typically do not consume
   any dynamic memory resources. 

@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\enum osThreadState_t
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\enum osPriority_t
\details
\note MUST REMAIN UNCHANGED: \b osPriority_t shall be consistent in every CMSIS-RTOS.
\note Cannot be called from \ref CMSIS_RTOS_ISR_Calls "Interrupt Service Routines".

The \b osPriority_t value specifies the priority for a thread. The default thread priority should be \a osPriorityNormal.
If a Thread is active that has a higher priority than the currently executing thread, then a thread switch occurs immediately
to execute the new task.

To prevent from a priority inversion, a CMSIS-RTOS compliant OS may optionally implement a <b>priority inheritance</b> method.
A priority inversion occurs when a high priority thread is waiting for a resource or event that is controlled by a thread
with a lower priority. 

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef void *(*os_thread_func_t) (void *argument)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef void (*os_timer_func_t) (void *argument)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef osThreadId_t

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\struct osThreadAttr_t

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\def osThreadJoinable
\details

*/
/**
\def osThreadDetached
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osThreadId_t osThreadNew (os_thread_func_t func, void *argument, const osThreadAttr_t *attr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osThreadId_t osThreadGetId (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osThreadState_t osThreadGetState (osThreadId_t thread_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osPriority_t osThreadGetPriority (osThreadId_t thread_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadYield (void)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadAbortWait (osThreadId_t thread_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadSuspend (osThreadId_t thread_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadResume (osThreadId_t thread_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadDetach (osThreadId_t thread_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadJoin (osThreadId_t thread_id, void **exit_ptr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn __NO_RETURN void osThreadExit (void *exit_ptr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osThreadTerminate (osThreadId_t thread_id)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Thread Flags Management ====
/** 
\addtogroup CMSIS_RTOS_ThreadFlagsMgmt Thread Flags Management Functions
\ingroup CMSIS_RTOS
\brief Lorem ipsum
\details
Lorem ipsum

@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \def osFlagsWaitAny
Wait forever timeout value. 

Reference: 
 - \ref osEventFlagsWait
 - \ref osThreadFlagsWait
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \def osFlagsWaitAll

Reference: 
 - \ref osEventFlagsWait
 - \ref osThreadFlagsWait
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \def osFlagsAutoClear

Reference: 
 - \ref osEventFlagsWait
 - \ref osThreadFlagsWait
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \fn int32_t osThreadFlagsSet (osThreadId_t thread_id, int32_t flags ) 	
<b>Code Example</b>
\code
\endcode
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \fn osStatus osThreadFlagsClear (osThreadId thread_id, int32_t flags);
 
<b>Code Example</b>
\code
\endcode
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \fn int32_t osThreadFlagsGet (osThreadId thread_id);
 
<b>Code Example</b>
\code
\endcode
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \fn int32_t osThreadFlagsWait (int32_t flags, uint32_t options, uint32_t millisec);

<b>Code Example</b>
\code
\endcode
*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Generic Wait Functions ====
/** 
\addtogroup CMSIS_RTOS_Wait Generic Wait Functions
\ingroup CMSIS_RTOS
\brief Wait for a time period or unspecified events.
\details 
The Generic Wait function group provides means for a time delay and allow to wait for unspecified events.

@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** \def osWaitForever
Wait forever timeout value. 

Reference: 
 - \ref osDelay
 - \ref osDelayUntil
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osDelay (uint32_t millisec);
\details
Wait for a specified time period in \a millisec.

The \ref CMSIS_RTOS_TimeOutValue "millisec" value specifies the number of timer ticks and is therefore an upper bound. The
exact time delay depends on the actual time elapsed since the last timer tick. 

For a value of <b>1</b>, the system waits until the next timer tick occurs. That means that the actual time delay may be up
to one timer tick less.

<b>\ref CMSIS_RTOS_Status</b>\n
 - \em osEventTimeout: the time delay is executed.
 - \em osErrorISR: \ref osDelay cannot be called from interrupt service routines.

\note Cannot be called from \ref CMSIS_RTOS_ISR_Calls "Interrupt Service Routines".
 
<b>Code Example</b>
\code
#include "cmsis_os.h"
 
void Thread_1 (void const *arg)  {               // Thread function
  osStatus status;                               // capture the return status
  uint32_t delayTime;                            // delay time in milliseconds
 
  delayTime = 1000;                              // delay 1 second
  status = osDelay (delayTime);                  // suspend thread execution
  if (status != osOK) {
    // handle error code
  }  
}
\endcode
*/ 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osDelayUntil (uint64_t millisec)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Timer Management Functions ====
/** 
\addtogroup CMSIS_RTOS_TimerMgmt Timer Management
\ingroup CMSIS_RTOS
\brief Create and control timer and timer callback functions.
\details 
In addition to the \ref CMSIS_RTOS_Wait CMSIS-RTOS also supports virtual timer objects. These timer objects can
trigger the execution of a function (not threads). When a timer expires, a callback function is executed to run associated
code with the timer. The timer number is passed as a parameter to the callback function. Each timer can be configured as a
one-shot or a  periodic timer. A periodic timer repeats its operation until it is \ref osTimerDelete "deleted" or
\ref osTimerStop "stopped". All timers can be \ref osTimerStart "started, restarted", or \ref osTimerStop "stopped".

Timers are handled in the thread \b osTimerThread. Callback functions run under control of this thread and may use other
CMSIS-RTOS API calls.

The figure below shows the behavior of a periodic timer. For one-shot timers, the timer stops after execution of the
callback function.

\image html "Timer.png" "Behavior of a Periodic Timer"

Working with Timers
--------------------
The following steps are required to use a timer:
-# Define the timers:
\code
//osTimerDef(one_shot, start_machine);  // when the timer expires, the function start_machine is called
//osTimerDef(periodic, toggle_power);   // when the timer expires, the function toggle_power is called
osTimerId one_shot_id, periodic_id;
\endcode
-# Instantiate and start the timers in an RTOS thread:
\code
one_shot_id = osTimerCreate(osTimer(one_shot), osTimerOnce, (void *)0);      // creates a one-shot timer;
                                                                             // (void*)0 is passed as an argument
                                                                             // to the callback function
periodic_id = osTimerCreate(osTimer(periodic), osTimerPeriodic, (void *)5);  // creates a periodic timer;
                                                                             // (void*)5 is passed as an argument
                                                                             // to the callback function
osTimerStart(one_shot_id, 500);
osTimerStart(periodic, 1500);
\endcode

@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\enum  osTimerType_t
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef osTimerId_t 
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\struct osTimerAttr_t 
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osTimerId_t osTimerNew (os_timer_func_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t millisec)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osTimerStop (osTimerId_t timer_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osTimerIsRunning (osTimerId_t timer_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osTimerDelete (osTimerId_t timer_id)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Event Flag Management ====
/** 
\addtogroup CMSIS_RTOS_EventFlags Event Flag Objects
\ingroup CMSIS_RTOS
\brief Synchronize threads using flags.
\details 
\todo add details here.
@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef osEventFlagsId_t 
\details
 
*/ 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\struct osEventFlagsAttr_t 
\details
 
*/ 
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Mutex Management ====
/** 
\addtogroup CMSIS_RTOS_MutexMgmt Mutexes
\ingroup CMSIS_RTOS
\brief Synchronize resource access using Mutual Exclusion (Mutex).
\details 
<b>Mutual exclusion</b> (widely known as \b Mutex) is used in various operating systems for resource management. Many
resources in a microcontroller device can be used repeatedly, but only by one thread at a time (for example communication
channels, memory, and files). Mutexes are used to protect access to a shared resource. A mutex is created and then passed
between the threads (they can acquire and release the mutex).

\image html "Mutex.png" "CMSIS-RTOS Mutex"

A mutex is a special version of a \ref CMSIS_RTOS_SemaphoreMgmt "semaphore". Like the semaphore, it is a container for
tokens. But instead of being able to have multiple tokens, a mutex can only carry one (representing the resource). Thus, a
mutex token is binary and bounded. The advantage of a mutex is that it introduces thread ownership. When a thread acquires a
mutex and becomes its owner, subsequent mutex acquires from that thread will succeed immediately without any latency. Thus,
mutex acquires/releases can be nested.

\note
- Mutex management functions cannot be called from interrupt service routines (ISR), unlike a binary semaphore that can be
  released from an ISR.

Working with Mutexes
--------------------
To use mutexes, you need to follow these steps for creating and using them:
-# Declare the mutex container and initialize the mutex:
\code
//osMutexDef (uart_mutex);    // Declare mutex
osMutexId  (uart_mutex_id); // Mutex ID
\endcode
-# Create the mutex in a thread:
\code
uart_mutex_id = osMutexCreate(osMutex(uart_mutex));
\endcode
-# Acquire the mutex when peripheral access is required:
\code
osMutexWait(uart_mutex_id, osWaitForever);
\endcode
-# When finished with the peripheral access, release the mutex:
\code
osMutexRelease(uart_mutex_id);
\endcode

@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\def osMutexRecursive
\details
 - \ref osMutexAttr_t
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\def osMutexPrioInherit
\details
 - \ref osMutexAttr_t
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\def osMutexRobust
\details
 - \ref osMutexAttr_t
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef osMutexId_t
\details

*/ 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\struct osMutexAttr_t
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osMutexId_t osMutexNew (const osMutexAttr_t *attr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t millisec)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osMutexRelease (osMutexId_t mutex_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osThreadId_t osMutexGetOwner (osMutexId_t mutex_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osMutexDelete (osMutexId_t mutex_id)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Semaphore Management ====
/** 
\addtogroup CMSIS_RTOS_SemaphoreMgmt Semaphores
\ingroup CMSIS_RTOS
\brief Access shared resources simultaneously from different threads.
\details 
Semaphores are used to manage and protect access to shared resources. Semaphores are very similar to
\ref CMSIS_RTOS_MutexMgmt "Mutexes". Whereas a Mutex permits just one thread to access a shared resource at a
time, a semaphore can be used to permit a fixed number of threads to access a pool of shared resources. Using semaphores,
access to a group of identical peripherals can be managed (for example multiple DMA channels).

\image html "Semaphore.png" "CMSIS-RTOS Semaphore"

A semaphore object should be initialized to the maximum number of available tokens. This number of available resources is
specified as parameter of the \ref osSemaphoreNew function. Each time a semaphore token is obtained with
\ref osSemaphoreAcquire, the semaphore count is decremented. When the semaphore count is 0, no semaphore token can be
obtained. The thread that tries to obtain the semaphore token needs to wait until the next token is free. Semaphores are
released with \ref osSemaphoreRelease incrementing the semaphore count.

\note Semaphore tokens can be acquired from threads and released from threads and ISRs.

Working with Semaphores
--------------------
Follow these steps to create and use a semaphore:
-# Declare the semaphore container and initialize the semaphore:
\code
osSemaphoreDef (my_semaphore);    // Declare semaphore
osSemaphoreId  (my_semaphore_id); // Semaphore ID
\endcode
-# Initialize the semaphore container with a number of tokens within a thread:
\code
my_semaphore_id = osSemaphoreCreate(osSemaphore(my_semaphore), 4);  // Create semaphore with 4 tokens
\endcode
\b Important: semaphore tokens can be created and destroyed as threads run. This means that can initialize a semaphore with
zero tokens and then use one thread to add/create tokens to the semaphore while a second thread removes them. In this way you
can distinguish between producer and consumer threads.
-# Acquire a token from the semaphore container:
\code
osSemaphoreWait(my_semaphore_id, osWaitForever);
\endcode
-# When finished using the semaphore resource, send the token back to the semaphore container:
\code
osSemaphoreRelease(my_semaphore_id);
\endcode

Semaphore Use Cases
-------------------
Due to their flexibility, semaphores cover a wide range of synchronizing applications. At the same time, they are perhaps the
most challenging RTOS object to understand. The following explains a use case for semaphores, taken from the book
<a href="http://www.greenteapress.com/semaphores/" target="_blank">The Little Book Of Semaphores</a> by Allen B. Downey which
is available for free download.

<b>Non-binary Semaphore (Multiplex)</b>

A multiplex limits the number of threads that can access a critical section of code. For example, this could be a function
accessing DMA resources which can only support a limited number of calls.

To allow multiple threads to run the function, initialize a semaphore to the maximum number of threads that can be allowed.
The number of tokens in the semaphore represents the number of additional threads that may enter. If this number is zero,
then the next thread trying to access the function will have to wait until one of the other threads exits and releases its
token. When all threads have exited the token number is back to n. Ths following example shows the code for one of the
threads that might access the resource:

\code
osSemaphoreDef(multiplex);
osSemaphoreId (multiplex_id);
 
void thread_n (void)
  {
    multiplex_id = osSemaphoreCreate(osSemaphore(multiplex), 3);
    while(1)
      {
        osSemaphoreWait(multiplex_id, osWaitForever);
        // do something
        osSemaphoreRelease(multiplex_id);
      }
  }
\endcode

@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef  osSemaphoreId_t
\details

*/
/**
\struct osSemaphoreAttr_t
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t millisec)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Memory Pool Management ====
/** 
\addtogroup CMSIS_RTOS_PoolMgmt Memory Pool
\ingroup CMSIS_RTOS
\brief Manage thread-safe fixed-size blocks of dynamic memory.
\details
\b Memory \b pools are fixed-size blocks of memory that are thread-safe. They operate much faster than the dynamically
allocated heap and do not suffer from fragmentation. Being thread-safe, they can be accessed from threads and ISRs alike.

\b Shared \b memory is one of the basic models to exchange information between threads. Using memory pools for exchanging
data, you can share more complex objects between threads if compared to a \ref CMSIS_RTOS_Message. Memory pool management
functions are used to define and manage such fixed-sized memory pools.

Working with Memory Pools
-------------------------
Follow these steps to create and use a memory pool:
-# Declare a data structure that combines a number of elements:
\code
typedef struct {
  uint32_t length;
  uint32_t width;
  uint32_t height;
  uint32_t weight;
} properties_t;
\endcode
-# Declare a memory pool of these objects as a block of memory:
\code
osPoolDef (object_pool, 10, properties_t);  // Declare memory pool
osPoolId  (object_pool_id);                 // Memory pool ID
\endcode
-# Then, create the memory pool in a thread:
\code
object_pool_id = osPoolCreate(osPool(object_pool));
\endcode
-# Allocate the pool within a thread and fill it with data:
\code
properties_t *object_data;
*object_data = (properties_t *) osPoolAlloc(object_pool_id);
 
object_data->length = 100;
object_data->width  = 10;
object_data->height = 23;
object_data->weight = 1000;
\endcode

@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\typedef osMemoryPoolId_t
\details 
 
*/
/** 
\struct osMemoryPoolAttr_t
\details 
 
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t millisec)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== Message Queue Management ====
/** 
@addtogroup CMSIS_RTOS_Message Message Queue
@ingroup CMSIS_RTOS
@brief Exchange messages between threads in a FIFO-like operation.
@details 
\b Message \b passing is another basic communication model between threads. In the message passing model, one thread sends
data explicitly, while another thread receives it. The operation is more like some kind of I/O rather than a direct access to
information to be shared. In CMSIS-RTOS, this mechanism is called s \b message \b queue. The data is passed from one thread
to another in a FIFO-like operation. Using message queue functions, you can control, send, receive, or wait for messages. The
data to be passed can be of integer or pointer type:

\image html "MessageQueue.png" "CMSIS-RTOS Message Queue"

Compared to a \ref CMSIS_RTOS_PoolMgmt, message queues are less efficient in general, but solve a broader range of problems.
Sometimes, threads do not have a common address space or the use of shared memory raises problems, such as mutual exclusion.

Working with Message Queues
---------------------------
Follow these steps to create and use a message queue:
-# Setup the message queue:
\code
osMessageQDef(message_q, 5, uint32_t); // Declare a message queue
osMessageQId (message_q_id);           // Declare an ID for the message queue
\endcode
-# Then, create the message queue in a thread:
\code
message_q_id = osMessageCreate(osMessageQ(message_q), NULL);
\endcode
-# Fill the message queue with data:
\code
uint32_t data = 512;
 
osMailPut(message_q_id, data, osWaitForever);
\endcode
-# From the receiving thread access the data using:
\code
osEvent event = osMessageGet(message_q_id, osWaitForever);
\endcode

@{
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\def osMessageQueueId_t
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\struct osMessageQueueAttr_t
\details
Attributes structure for message queue.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t millisec)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t millisec)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id)
\details

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/** 
\fn osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id)
\details

*/
/// @}


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
// ==== Status and Error Codes ====
/**
\addtogroup CMSIS_RTOS_Status Status and Error Codes
\ingroup CMSIS_RTOS
\brief Status and Error Codes returned by CMSIS-RTOS API functions.
\details The Status and Error Codes section lists all the return values that the CMSIS-RTOS functions will return.
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\typedef osStatus_t
\details
The \b osStatus_t enumeration defines the event status and error codes that are returned by the CMSIS-RTOS functions.
*/
/// @} 



